<!DOCTYPE html>
<html lang="pt-BR">
<head>
	<meta charset="UTF-8">
	<title>Espelho M√°gico</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="apple-touch-icon" sizes="180x180" href="../assets/favicon/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="../assets/favicon/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="../assets/favicon/favicon-16x16.png">
	<link rel="icon" href="../assets/favicon/favicon.ico">
	<meta name="OPENAI_API_KEY" content="">
	<meta name="ELEVENLABS_API_KEY" content="">
	<link rel="stylesheet" href="../styles/mirror.css">
</head>
<body>
	<div class="app">
		<canvas id="bg"></canvas>
		<div class="portal" aria-hidden="true"></div>
		<div class="center">
			<div id="mirror" class="mirror closed">
				<div class="mirror-inner">
					<video id="cam" autoplay playsinline muted></video>
					<img id="result-img" class="hidden" alt="resultado"/>
					<div id="mirror-overlay"></div>
				</div>
			</div>
			<div class="state" id="state">Toque em ‚ÄúCome√ßar‚Äù para abrir o espelho.</div>
			<div class="controls">
				<button id="btn-start" class="btn btn-primary" aria-label="Come√ßar">Come√ßar</button>
				<button id="btn-mic" class="btn hidden" aria-label="Gravar √°udio">
					<svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
						<path d="M12 1a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
						<path d="M19 10a7 7 0 0 1-14 0"></path>
						<path d="M12 19v4"></path>
					</svg>
				</button>
				<button id="btn-download" class="btn hidden">Baixar imagem</button>
				<button id="btn-home" class="btn hidden">Voltar ao in√≠cio</button>
			</div>
		</div>
	</div>
	<script>
		// Injeta env
		(async function injectEnv(){
			try {
				const r = await fetch('/api/env'); if (!r.ok) return;
				const env = await r.json();
				const set = (k,v) => { const m = document.querySelector(`meta[name="${k}"]`); if (m && v) m.setAttribute('content', v); };
				set('OPENAI_API_KEY', env.OPENAI_API_KEY || '');
				set('ELEVENLABS_API_KEY', env.ELEVENLABS_API_KEY || '');
			} catch {}
		})();

		// Fundo \"massinha viva\" multicolorida (metaballs leves) + part√≠culas com intera√ß√£o do mouse
		(function gooeyBackground(){
			const canvas = document.getElementById('bg');
			const ctx = canvas.getContext('2d');
			let w, h, dpr;
			// controle din√¢mico de carga visual
			let blobs = [], particles = [];
			let numBlobs = 0, numParticles = 0;
			let baselineTargets = { blobs: 90, particles: 220 };
			let fpsAvg = 60, lastT = performance.now(), frameCount = 0;
			const palette = [330, 340, 350, 210, 200, 220, 280, 290, 265];

			const resize = () => {
				dpr = window.devicePixelRatio || 1;
				w = canvas.clientWidth; h = canvas.clientHeight;
				canvas.width = Math.floor(w * dpr); canvas.height = Math.floor(h * dpr);
				ctx.setTransform(dpr,0,0,dpr,0,0);
				updateTargetsFromEnv();
			};
			window.addEventListener('resize', resize); resize();
			// cria√ß√£o de itens
			function createBlob(){
				const baseHue = palette[Math.floor(Math.random()*palette.length)];
				return {
					x: Math.random()*w, y: Math.random()*h,
					r: 120 + Math.random()*420,
					h: baseHue + (Math.random()*8-4),
					s: 78 + Math.random()*10,
					l: 68 + Math.random()*10,
					vx: (Math.random()*0.4-0.2), vy: (Math.random()*0.4-0.2)
				};
			}
			function createParticle(){
				const baseHue = palette[Math.floor(Math.random()*palette.length)];
				return {
					x: Math.random()*w, y: Math.random()*h,
					r: 0.6 + Math.random()*1.6,
					s: 0.25 + Math.random()*0.6,
					h: baseHue + (Math.random()*10-5)
				};
			}
			function ensureArraySize(arr, needed, createFn){
				if (arr.length < needed) {
					const toAdd = needed - arr.length;
					for (let i=0;i<toAdd;i++) arr.push(createFn());
				} else if (arr.length > needed) {
					arr.length = needed;
				}
			}
			function computeTargets(){
				const minSide = Math.min(window.innerWidth || w, window.innerHeight || h);
				const isVerySmall = minSide <= 380;
				const isSmall = minSide <= 540;
				const cores = navigator.hardwareConcurrency || 4;
				const lowCore = cores <= 4;
				const highDPR = (window.devicePixelRatio || dpr || 1) > 2;
				const prefersReducedMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
				// baseline
				let blobsTarget = 90;
				let particlesTarget = 220;
				// multiplicadores
				let m = 1.0;
				if (isSmall) m *= 0.45;
				if (isVerySmall) m *= 0.62; // adicional sobre o pequeno
				if (lowCore) m *= 0.75;
				if (highDPR) m *= 0.8;
				if (prefersReducedMotion) m *= 0.25;
				// clamp
				m = Math.max(0.12, Math.min(1, m));
				blobsTarget = Math.max(20, Math.round(blobsTarget * m));
				particlesTarget = Math.max(40, Math.round(particlesTarget * m));
				return { blobs: blobsTarget, particles: particlesTarget };
			}
			function applyTargets(t){
				baselineTargets = { ...t };
				// ajustar imediatamente arrays ao baseline e usar como base para ajustes din√¢micos
				numBlobs = t.blobs;
				numParticles = t.particles;
				ensureArraySize(blobs, numBlobs, createBlob);
				ensureArraySize(particles, numParticles, createParticle);
			}
			function updateTargetsFromEnv(){
				const t = computeTargets();
				applyTargets(t);
			}
			if (window.matchMedia) {
				try {
					const mq = window.matchMedia('(prefers-reduced-motion: reduce)');
					mq.addEventListener ? mq.addEventListener('change', updateTargetsFromEnv) : mq.addListener(updateTargetsFromEnv);
				} catch {}
			}
			let t = 0;
			// intera√ß√£o do mouse
			const mouse = { x: 0, y: 0, active: true };
			const toLocal = (e) => {
				const rect = canvas.getBoundingClientRect();
				mouse.x = (e.clientX - rect.left);
				mouse.y = (e.clientY - rect.top);
				mouse.active = true;
			};
			window.addEventListener('pointermove', toLocal);
			function drawBlob(b){
				// Garantir que o raio seja sempre positivo e v√°lido
				const radius = Math.max(1, b.r || 1);
				const innerRadius = Math.max(0.1, radius * 0.12);
				if (radius <= 0 || innerRadius <= 0) return; // Skip se inv√°lido
				const grad = ctx.createRadialGradient(b.x, b.y, innerRadius, b.x, b.y, radius);
				// Centro mais escuro e saturado para manter cor nas sobreposi√ß√µes
				grad.addColorStop(0, `hsla(${b.h}, ${Math.min(b.s+8, 96)}%, ${Math.max(b.l-14, 46)}%, 0.82)`);
				grad.addColorStop(0.6, `hsla(${b.h+6}, ${Math.max(b.s-6, 60)}%, ${Math.max(b.l-6, 52)}%, 0.58)`);
				// Borda totalmente transparente NA MESMA COR (evita halo branco)
				grad.addColorStop(1, `hsla(${b.h}, ${Math.max(b.s-12, 50)}%, ${b.l}%, 0)`);
				ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(b.x,b.y,radius,0,Math.PI*2); ctx.fill();
			}
			// ponte simple entre blobs pr√≥ximos (ajuda parecer l√≠quido)
			function bridge(a, b){
				const dx = b.x - a.x, dy = b.y - a.y;
				const d = Math.hypot(dx, dy);
				if (d > (a.r + b.r) * 0.55) return;
				const mx = a.x + dx * 0.5, my = a.y + dy * 0.5;
				const r = Math.min(a.r, b.r) * Math.max(0.22, 0.55 - d / (a.r + b.r));
				const hue = (a.h + b.h) / 2;
				const grad = ctx.createRadialGradient(mx, my, r*0.2, mx, my, r);
				grad.addColorStop(0, `hsla(${hue}, 70%, 62%, 0.45)`);
				// Borda transparente na cor m√©dia (sem fosco branco)
				grad.addColorStop(1, `hsla(${hue}, 60%, 62%, 0)`);
				ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(mx, my, r, 0, Math.PI*2); ctx.fill();
			}
			function loop(){
				// fps m√©dio
				const now = performance.now();
				const dt = Math.max(1, now - lastT);
				lastT = now;
				const fpsInst = 1000 / dt;
				fpsAvg = fpsAvg * 0.95 + fpsInst * 0.05;
				frameCount++;

				t += 0.016;
				ctx.clearRect(0,0,w,h);
				// mistura que preserva cor sem estourar para branco
				ctx.globalCompositeOperation = 'soft-light';
				for (let i = 0; i < numBlobs; i++) {
					const b = blobs[i];
					// atra√ß√£o/repuls√£o suave ao mouse
					const dx = mouse.x - b.x;
					const dy = mouse.y - b.y;
					const dist = Math.hypot(dx, dy) || 0.0001;
					const influence = 340;
					if (dist < influence) {
						const f = (1 - dist / influence);
						// acelera√ß√£o mais baixa para movimento mais devagar
						const accel = 0.0006 * (f*f + 0.12);
						b.vx += dx * accel;
						b.vy += dy * accel;
						// leve repuls√£o quando muito pr√≥ximo do centro
						if (dist < b.r * 0.6) {
							b.vx -= dx * 0.0010 * (1 - dist / (b.r * 0.6));
							b.vy -= dy * 0.0010 * (1 - dist / (b.r * 0.6));
						}
						b.h += Math.sin(t*0.8 + dist*0.01) * 0.25;
					}
					b.x += b.vx; b.y += b.vy;
					// bounce suave
					if (b.x < -b.r) { b.x = -b.r; b.vx *= -1; }
					if (b.y < -b.r) { b.y = -b.r; b.vy *= -1; }
					if (b.x > w + b.r) { b.x = w + b.r; b.vx *= -1; }
					if (b.y > h + b.r) { b.y = h + b.r; b.vy *= -1; }
					b.r += Math.sin(t*0.6 + b.x*0.001 + b.y*0.0015) * 0.5;
					drawBlob(b);
				}
				// pontes entre blobs pr√≥ximos
				for (let i = 0; i < numBlobs; i++) {
					for (let j = i+1; j < numBlobs; j++) {
						bridge(blobs[i], blobs[j]);
					}
				}
				ctx.globalCompositeOperation = 'source-over';
				// part√≠culas brilhantes
				for (let i = 0; i < numParticles; i++) {
					const p = particles[i];
					p.x += Math.sin((p.y+t*40)/60)*p.s*0.6 + (Math.sin(t*0.8)*0.3);
					p.y -= p.s;
					if (p.y < -5) { p.y = h+5; p.x = Math.random()*w; }
					ctx.fillStyle = `hsla(${p.h + (Math.sin(t*2)*8)}, 85%, 85%, 0.8)`;
					ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill();
				}
				// ajuste din√¢mico por FPS a cada ~60 frames
				if (frameCount % 60 === 0) {
					const target = baselineTargets;
					const isSmallNow = Math.min(window.innerWidth || w, window.innerHeight || h) <= 540;
					if (fpsAvg < 45) {
						// reduzir 12-18%
						numBlobs = Math.max(12, Math.round(numBlobs * 0.85));
						numParticles = Math.max(24, Math.round(numParticles * 0.85));
						ensureArraySize(blobs, numBlobs, createBlob);
						ensureArraySize(particles, numParticles, createParticle);
					} else if (fpsAvg > 58 && !isSmallNow) {
						// recuperar gradualmente at√© o baseline
						const nextBlobs = Math.min(target.blobs, Math.round(numBlobs * 1.1 + 1));
						const nextParticles = Math.min(target.particles, Math.round(numParticles * 1.1 + 2));
						if (nextBlobs !== numBlobs) { numBlobs = nextBlobs; ensureArraySize(blobs, numBlobs, createBlob); }
						if (nextParticles !== numParticles) { numParticles = nextParticles; ensureArraySize(particles, numParticles, createParticle); }
					}
				}
				requestAnimationFrame(loop);
			}
			loop();
		})();

		// Webcam
		const $video = document.getElementById('cam');
		const $mirror = document.getElementById('mirror');
		const $result = document.getElementById('result-img');
		const $state = document.getElementById('state');
		const $btnStart = document.getElementById('btn-start');
		const $btnMic = document.getElementById('btn-mic');
		const $btnDownload = document.getElementById('btn-download');
		const $btnHome = document.getElementById('btn-home');
		let stream;

		async function openCamera(){
			try {
				stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: false });
				$video.srcObject = stream;
				return true;
			} catch (e) {
				$state.textContent = 'N√£o foi poss√≠vel acessar a c√¢mera.';
				return false;
			}
		}
		function closeCamera(){
			try {
				if (stream) { stream.getTracks().forEach(t => t.stop()); }
			} catch {}
			stream = null;
			try { $video.srcObject = null; } catch {}
		}

		// Grava√ß√£o de √°udio
		let mediaRecorder, audioChunks = [], isRecording = false;
		async function startRecording(){
			const audioStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true } });
			mediaRecorder = new MediaRecorder(audioStream);
			audioChunks = [];
			mediaRecorder.ondataavailable = e => { if (e.data.size > 0) audioChunks.push(e.data); };
			mediaRecorder.start();
			isRecording = true;
			$btnMic.classList.add('recording');
			$state.textContent = 'Gravando... toque novamente para parar.';
		}
		async function stopRecording(){
			return new Promise(resolve => {
				mediaRecorder.onstop = () => {
					isRecording = false;
					$btnMic.classList.remove('recording');
					const blob = new Blob(audioChunks, { type: 'audio/webm' });
					resolve(blob);
				};
				try { mediaRecorder.stop(); } catch {}
			});
		}

		function getEnv(key){ const m = document.querySelector(`meta[name="${key}"]`); return (m && m.getAttribute('content')) || ''; }

		// STT: usa apenas OpenAI Whisper
		async function transcribe(blob){
			console.log('üé§ Iniciando transcri√ß√£o de √°udio com OpenAI Whisper...');
			const openaiKey = (getEnv('OPENAI_API_KEY') || '').trim();
			if (!openaiKey) throw new Error('OPENAI_API_KEY ausente');
			
			console.log('üì§ Preparando √°udio para envio ao Whisper...');
			const form = new FormData();
			const file = new File([blob], 'audio.webm', { type: 'audio/webm' });
			form.append('file', file);
			form.append('model', 'whisper-1');
			form.append('language', 'pt');
			
			console.log('üöÄ Enviando para OpenAI Whisper API...');
			const startTime = Date.now();
			const resp = await fetch('https://api.openai.com/v1/audio/transcriptions', {
				method:'POST',
				headers: { 'Authorization': 'Bearer ' + openaiKey },
				body: form
			});
			const duration = Date.now() - startTime;
			
			if (!resp.ok) {
				const err = await resp.text();
				console.error('‚ùå Erro na transcri√ß√£o Whisper:', err);
				throw new Error('STT error: ' + err);
			}
			
			console.log(`‚úÖ Resposta recebida do Whisper (${duration}ms)`);
			const data = await resp.json();
			const transcript = (data && (data.text || data.transcription || '').trim()) || '';
			
			console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
			console.log('‚úÖ TRANSCRI√á√ÉO DA FALA DO USU√ÅRIO (Whisper):');
			console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
			console.log('"', transcript, '"');
			console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
			return transcript;
		}

		function snapshot(){
			const canvas = document.createElement('canvas');
			const rect = $video.getBoundingClientRect();
			const w = $video.videoWidth || Math.round(rect.width * window.devicePixelRatio);
			const h = $video.videoHeight || Math.round(rect.height * window.devicePixelRatio);
			canvas.width = w; canvas.height = h;
			const ctx = canvas.getContext('2d');
			// espelho (flip horizontal)
			ctx.translate(w, 0); ctx.scale(-1, 1);
			ctx.drawImage($video, 0, 0, w, h);
			return canvas.toDataURL('image/png');
		}

		// Fluxo: Come√ßar ‚Üí abre "magicamente" e habilita microfone
		$btnStart.addEventListener('click', async () => {
			try {
				$btnStart.disabled = true;
				$state.textContent = 'Abrindo o espelho...';
				// Garante que o v√≠deo esteja vis√≠vel e a imagem resultante escondida
				$result.classList.add('hidden');
				$video.classList.remove('hidden');
				$mirror.classList.remove('closed');
				$mirror.classList.add('opening');
				const ok = await openCamera();
				// pequena dura√ß√£o para a anima√ß√£o de abertura
				await new Promise(r => setTimeout(r, 600));
				$mirror.classList.remove('opening');
				if (ok) {
					$btnMic.classList.remove('hidden');
					$state.textContent = 'Toque no microfone e descreva seu estilo de vida.';
					$btnStart.classList.add('hidden');
				} else {
					$mirror.classList.add('closed');
				}
			} finally {
				$btnStart.disabled = false;
			}
		});

		async function generateAgedImage({ photoDataUrl, transcript }){
			console.log('üñºÔ∏è ===== ENVIANDO FOTO PARA IA ENVELHECER =====');
			console.log('üì∏ Foto capturada (tamanho base64):', photoDataUrl.length, 'caracteres');
			
			// Mostra a transcri√ß√£o recebida de forma destacada
			console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
			console.log('üí¨ TRANSCRI√á√ÉO RECEBIDA (estilo de vida do usu√°rio):');
			console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
			console.log(transcript || '(nenhuma transcri√ß√£o fornecida)');
			console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
			
			// PROMPT BASE que ser√° enviado (ser√° combinado com o estilo de vida no backend)
			// O prompt ser√°: prompt base + o que o usu√°rio disse (limitado a 1000 caracteres)
			const promptBaseText = 'Transform this photo to appear realistically older (80 years old) while fully preserving identity, facial features, skin tone, proportions, hairstyle, framing, pose, background, and lighting. Apply natural aging for 80 years: deeper wrinkles, age spots, mature skin texture, loss of firmness, gray/white hair, thinning hair, sagging skin. No filters, stylization, makeup, or graphic elements. Maintain realistic high-fidelity photography.';
			const MAX_PROMPT_LENGTH = 1000;
			const baseLength = promptBaseText.length;
			const suffixLength = transcript ? ' Incorporate lifestyle: . Output realistic 80-year-old version, maintaining fidelity.'.length : ' Output realistic 80-year-old version, maintaining fidelity.'.length;
			const availableForTranscript = MAX_PROMPT_LENGTH - baseLength - suffixLength;
			
			let finalTranscript = transcript || '';
			if (transcript && transcript.length > availableForTranscript) {
				finalTranscript = transcript.substring(0, availableForTranscript - 3) + '...';
				console.log(`‚ö†Ô∏è Transcri√ß√£o ser√° truncada no backend para n√£o exceder ${MAX_PROMPT_LENGTH} caracteres`);
			}
			
			const promptBase = finalTranscript 
				? `${promptBaseText} Incorporate lifestyle: ${finalTranscript}. Output realistic 80-year-old version, maintaining fidelity.`
				: `${promptBaseText} Output realistic 80-year-old version, maintaining fidelity.`;
			
			console.log(`üìè Tamanho estimado do prompt: ${promptBase.length} caracteres (limite: ${MAX_PROMPT_LENGTH})`);
			
			console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
			console.log('üìù PROMPT COMPLETO QUE SER√Å ENVIADO PARA A IA:');
			console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
			console.log('PROMPT BASE + O QUE O USU√ÅRIO DISSE:');
			console.log(promptBase);
			console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
			console.log('üöÄ Enviando para /api/age-image ‚Üí OpenAI /v1/images/edits...');
			const requestStartTime = Date.now();
			
			const resp = await fetch('/api/age-image', {
				method:'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ photoDataUrl, transcript })
			});
			const requestDuration = Date.now() - requestStartTime;
			
			console.log(`üì• Resposta recebida do backend (${requestDuration}ms)`);
			console.log('üìä Status HTTP:', resp.status, resp.statusText);
			
			if (!resp.ok) {
				const err = await resp.text();
				console.error('‚ùå Erro ao gerar imagem:', err);
				throw new Error('Falha ao gerar imagem: ' + err);
			}
			
			console.log('‚úÖ Resposta OK, processando JSON...');
			const { imageDataUrl } = await resp.json();
			console.log('‚úÖ Imagem envelhecida recebida (tamanho base64):', imageDataUrl.length, 'caracteres');
			console.log('üñºÔ∏è ===== PROCESSAMENTO CONCLU√çDO =====');
			return imageDataUrl;
		}

		let lastImageDataUrl = '';
		$btnMic.addEventListener('click', async () => {
			try {
				$btnMic.disabled = true;
				if (!isRecording) {
					await startRecording();
				} else {
					// parar, desfocar, aguardar 2s com c√¢mera ligada, fotografar, transcrever, gerar imagem
					console.log('‚èπÔ∏è Parando grava√ß√£o de √°udio...');
					const audioBlob = await stopRecording();
					console.log('üì¶ √Åudio gravado (tamanho):', audioBlob.size, 'bytes');
					$state.textContent = 'Processando sua fala e imagem...';
					$mirror.classList.add('blur');
					console.log('‚è≥ Aguardando 2 segundos antes de capturar foto...');
					await new Promise(r => setTimeout(r, 2000));
					console.log('üì∑ Capturando foto da c√¢mera...');
					const photo = snapshot();
					console.log('‚úÖ Foto capturada!');
					console.log('üé§ Iniciando transcri√ß√£o do √°udio...');
					const transcript = await transcribe(audioBlob);
					$state.textContent = 'Gerando sua vers√£o mais velha...';
					console.log('ü§ñ Enviando foto e transcri√ß√£o para IA envelhecer...');
					const aged = await generateAgedImage({ photoDataUrl: photo, transcript });
					lastImageDataUrl = aged;
					// Esconde o v√≠deo e mostra a imagem resultante
					console.log('üñºÔ∏è Exibindo imagem envelhecida no espelho...');
					$video.classList.add('hidden');
					$result.src = aged;
					$result.classList.remove('hidden');
					$mirror.classList.remove('blur');
					$btnDownload.classList.remove('hidden');
					$state.textContent = 'Pronto! Sua imagem apareceu no espelho.';
					console.log('‚úÖ Processo completo finalizado!');
					// Fecha c√¢mera e troca microfone por "Voltar ao in√≠cio"
					closeCamera();
					$btnMic.classList.add('hidden');
					$btnHome.classList.remove('hidden');
				}
			} catch (e) {
				console.error(e);
				$state.textContent = 'Ocorreu um erro. Tente novamente.';
				$mirror.classList.remove('blur');
			} finally {
				$btnMic.disabled = false;
			}
		});

		$btnDownload.addEventListener('click', () => {
			try {
				const a = document.createElement('a');
				a.href = lastImageDataUrl;
				a.download = 'espelho-magico.png';
				a.click();
			} catch {}
		});
		$btnHome.addEventListener('click', () => {
			// volta ao in√≠cio: espelho fechado e somente "Come√ßar"
			closeCamera();
			$result.classList.add('hidden');
			$video.classList.remove('hidden'); // Restaura o v√≠deo para pr√≥xima vez
			lastImageDataUrl = '';
			$btnDownload.classList.add('hidden');
			$btnHome.classList.add('hidden');
			$btnMic.classList.add('hidden');
			$btnStart.classList.remove('hidden');
			$mirror.classList.add('closed');
			$state.textContent = 'Toque em "Come√ßar" para abrir o espelho.';
		});

		// Console de debug secreto: pressionar "G" 10 vezes seguidas
		(function debugConsole(){
			let gCount = 0;
			let lastGTime = 0;
			let debugPanel = null;
			const G_TIMEOUT = 2000; // 2 segundos para resetar contador
			
			function createDebugPanel(){
				if (debugPanel) return;
				debugPanel = document.createElement('div');
				debugPanel.id = 'debug-console';
				debugPanel.style.cssText = `
					position: fixed;
					top: 20px;
					right: 20px;
					width: 400px;
					height: 300px;
					background: rgba(0, 0, 0, 0.85);
					color: #0f0;
					font-family: 'Courier New', monospace;
					font-size: 12px;
					padding: 12px;
					border: 2px solid #0f0;
					border-radius: 8px;
					z-index: 10000;
					overflow-y: auto;
					cursor: move;
					resize: both;
					box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
				`;
				debugPanel.innerHTML = '<div style="color:#0f0; font-weight:bold; margin-bottom:8px; border-bottom:1px solid #0f0; padding-bottom:4px;">DEBUG CONSOLE [Arraste para mover]</div><div id="debug-log"></div>';
				document.body.appendChild(debugPanel);
				
				// Tornar arrast√°vel
				let isDragging = false;
				let startX, startY, startLeft, startTop;
				debugPanel.addEventListener('mousedown', (e) => {
					if (e.target.id === 'debug-log' || e.target.closest('#debug-log')) return;
					isDragging = true;
					startX = e.clientX;
					startY = e.clientY;
					const rect = debugPanel.getBoundingClientRect();
					startLeft = rect.left;
					startTop = rect.top;
					debugPanel.style.cursor = 'grabbing';
				});
				document.addEventListener('mousemove', (e) => {
					if (!isDragging) return;
					const dx = e.clientX - startX;
					const dy = e.clientY - startY;
					debugPanel.style.left = (startLeft + dx) + 'px';
					debugPanel.style.top = (startTop + dy) + 'px';
					debugPanel.style.right = 'auto';
				});
				document.addEventListener('mouseup', () => {
					isDragging = false;
					if (debugPanel) debugPanel.style.cursor = 'move';
				});
				
				// Interceptar TODOS os m√©todos do console
				const originalLog = console.log;
				const originalError = console.error;
				const originalWarn = console.warn;
				const originalInfo = console.info;
				const originalDebug = console.debug;
				const originalTrace = console.trace;
				const originalDir = console.dir;
				const originalTable = console.table;
				const logDiv = document.getElementById('debug-log');
				
				function addLog(type, args){
					if (!logDiv) return;
					const time = new Date().toLocaleTimeString();
					const msg = Array.from(args).map(a => {
						if (typeof a === 'object' && a !== null) {
							try {
								return JSON.stringify(a, null, 2);
							} catch {
								return String(a);
							}
						}
						return String(a);
					}).join(' ');
					const color = type === 'error' ? '#f00' : type === 'warn' ? '#ff0' : type === 'info' ? '#0ff' : '#0f0';
					const entry = document.createElement('div');
					entry.style.cssText = `color:${color}; margin:2px 0; word-wrap:break-word; font-size:11px; line-height:1.4;`;
					entry.innerHTML = `<span style="opacity:0.6;">[${time}]</span> <span style="color:${color};">${msg}</span>`;
					logDiv.appendChild(entry);
					logDiv.scrollTop = logDiv.scrollHeight;
					// Limitar a 200 entradas
					while (logDiv.children.length > 200) logDiv.removeChild(logDiv.firstChild);
				}
				
				// Interceptar todos os m√©todos do console
				console.log = function(...args){
					originalLog.apply(console, args);
					addLog('log', args);
				};
				console.error = function(...args){
					originalError.apply(console, args);
					addLog('error', args);
				};
				console.warn = function(...args){
					originalWarn.apply(console, args);
					addLog('warn', args);
				};
				console.info = function(...args){
					originalInfo.apply(console, args);
					addLog('info', args);
				};
				console.debug = function(...args){
					originalDebug.apply(console, args);
					addLog('debug', args);
				};
				console.trace = function(...args){
					originalTrace.apply(console, args);
					addLog('trace', args);
				};
				console.dir = function(...args){
					originalDir.apply(console, args);
					addLog('dir', args);
				};
				console.table = function(...args){
					originalTable.apply(console, args);
					addLog('table', args);
				};
				
				// Interceptar erros globais e de rede
				window.addEventListener('error', (e) => {
					addLog('error', [`‚ùå Erro global: ${e.message}`, `Arquivo: ${e.filename}:${e.lineno}:${e.colno}`]);
				});
				
				window.addEventListener('unhandledrejection', (e) => {
					addLog('error', [`‚ùå Promise rejeitada: ${e.reason}`]);
				});
				
				// Interceptar fetch para capturar erros de rede
				const originalFetch = window.fetch;
				window.fetch = async function(...args){
					const url = args[0];
					const startTime = Date.now();
					try {
						const response = await originalFetch.apply(this, args);
						const duration = Date.now() - startTime;
						if (!response.ok) {
							addLog('warn', [`‚ö†Ô∏è Fetch ${response.status}: ${url} (${duration}ms)`]);
						} else {
							addLog('log', [`‚úÖ Fetch ${response.status}: ${url} (${duration}ms)`]);
						}
						return response;
					} catch (error) {
						const duration = Date.now() - startTime;
						addLog('error', [`‚ùå Fetch falhou: ${url} - ${error.message} (${duration}ms)`]);
						throw error;
					}
				};
				
				console.log('üîß Console de debug ativado!');
				console.log('üì° Intercepta√ß√£o de fetch ativada para capturar erros de rede');
			}
			
			function removeDebugPanel(){
				if (debugPanel) {
					debugPanel.remove();
					debugPanel = null;
				}
			}
			
			window.addEventListener('keydown', (e) => {
				if (e.key.toLowerCase() === 'g' && !e.ctrlKey && !e.altKey && !e.metaKey) {
					const now = Date.now();
					if (now - lastGTime > G_TIMEOUT) {
						gCount = 0;
					}
					lastGTime = now;
					gCount++;
					
					if (gCount >= 10) {
						gCount = 0;
						if (debugPanel) {
							removeDebugPanel();
						} else {
							createDebugPanel();
						}
					}
				}
			});
		})();
	</script>
</body>
</html>

